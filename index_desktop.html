<!DOCTYPE html>
<html lang="de" class="h-full">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AxisMea (desktop)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="assets/icons/home-solid-white.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-color: #3d3846;
            --text-color: #fafafa;
            --text-color-light: #a3a3a3;
            --topbar-bg: rgba(23, 23, 23, 0.85);
            --topbar-text: #fafafa;
            --dropdown-bg: #262626;
            --accent-color: #7c3aed;
            --accent-color-hover: #8b5cf6;
            --window-bg: #302b38;
            --window-header-bg: #211e25;
            --dock-bg: rgba(23, 23, 23, 0.7);
            --dock-border: #404040;
        }

        html[data-theme='light'] {
            --bg-color: #f0f0f0;
            --text-color: #111827;
            --text-color-light: #6b7280;
            --topbar-bg: rgba(255, 255, 255, 0.85);
            --topbar-text: #111827;
            --dropdown-bg: #ffffff;
            --window-bg: #fdfdfd;
            --window-header-bg: #e0e0e0;
            --dock-bg: rgba(255, 255, 255, 0.7);
            --dock-border: #e5e7eb;
        }

        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        html,
        body {
            height: 100%;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }

        body.dynamic-background {
            background: linear-gradient(-45deg, #0d0221, #241744, #3b2a6b, #4b3a8f);
            background-size: 400% 400%;
            animation: gradientAnimation 25s ease infinite;
        }

        body.static-background {
            background-color: var(--bg-color);
            animation: none;
        }

        #starfield-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }


        /* Styling for desktop icons based on theme */
        html[data-theme='dark'] .desktop-icon img,
        html[data-theme='dark'] .dock-desktop-icon {
            filter: invert(1);
        }

        html[data-theme='light'] .desktop-icon img,
        html[data-theme='light'] .dock-desktop-icon {
            filter: none;
        }

        html[data-theme='dark'] .desktop-icon span {
            color: #FFFFFF;
        }

        html[data-theme='light'] .desktop-icon span {
            color: #000000;
        }

        #top-bar {
            background-color: var(--topbar-bg);
            color: var(--topbar-text);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .top-bar-menu {
            position: relative;
        }

        .top-bar-menu>button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        /* Styling for Lucide icons */
        .lucide {
            width: 20px;
            height: 20px;
            stroke: var(--text-color-light);
            stroke-width: 2;
            fill: none;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background-color: var(--dropdown-bg);
            border: 1px solid var(--dock-border);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10001;
            width: 200px;
            overflow: hidden;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            color: var(--text-color);
        }

        .dropdown-item:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .dropdown-item.active {
            background-color: var(--accent-color-hover);
            color: white;
        }

        .dropdown-separator {
            height: 1px;
            background-color: var(--dock-border);
            margin: 4px 0;
        }

        #desktop {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .desktop-icon {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80px;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            user-select: none;
        }

        .desktop-icon:hover {
            background-color: rgba(128, 128, 128, 0.2);
        }

        .desktop-icon img {
            width: 48px;
            height: 48px;
            margin-bottom: 4px;
        }

        .desktop-icon span {
            font-size: 12px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        .app-window {
            position: absolute;
            background-color: var(--window-bg);
            border: 1px solid var(--dock-border);
            border-radius: 12px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            transition: top 0.3s ease, left 0.3s ease, width 0.3s ease, height 0.3s ease;
        }

        .app-window-header {
            background-color: var(--window-header-bg);
            padding: 4px 12px;
            cursor: move;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .app-window-header h3 {
            color: var(--text-color);
            font-weight: bold;
        }

        .window-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            position: relative;
        }

        .window-control-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .window-control-btn.close:hover {
            background-color: #ff5f57;
        }

        .window-control-btn.close:hover .lucide {
            stroke: #4d0000;
        }

        .window-control-btn.arrange:hover {
            background-color: #28c940;
        }

        .window-control-btn.arrange:hover .lucide {
            stroke: #003d00;
        }

        .window-control-btn.minimize:hover {
            background-color: #ffc107;
        }

        .window-control-btn.minimize:hover .lucide {
            stroke: #664d00;
        }

        .lucide.text-red-500 {
            stroke: #ef4444;
        }

        .lucide.text-yellow-400 {
            stroke: #facc15;
        }


        .app-window-content {
            flex-grow: 1;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .window-loader {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--window-bg);
            z-index: 5;
        }

        .app-window-content iframe {
            width: 100%;
            height: 100%;
            border: 0;
            background-color: transparent;
        }

        #app-dock {
            position: fixed;
            bottom: calc(4px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem;
            background-color: var(--dock-bg);
            border: 1px solid var(--dock-border);
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            gap: 1rem;
            z-index: 9999;
            transition: background-color 0.3s ease;
            max-width: 90vw;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
        }

        /* Custom scrollbar for WebKit browsers (Chrome, Safari) */
        #app-dock::-webkit-scrollbar {
            height: 8px;
            /* Height of the horizontal scrollbar */
        }

        #app-dock::-webkit-scrollbar-track {
            background: transparent;
            /* Transparent track */
        }

        #app-dock::-webkit-scrollbar-thumb {
            background: transparent;
            /* Initially transparent thumb */
            border-radius: 4px;
            /* Rounded corners for the thumb */
        }

        #app-dock:hover::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            /* Slightly visible thumb on hover */
        }

        #app-dock::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
            /* Darker thumb on hover */
        }


        .dock-app-item {
            position: relative;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            /* Prevent items from shrinking */
        }

        .dock-app-item:hover {
            transform: translateY(-10px);
        }

        .dock-app-item::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background-color: #3b82f6;
            border-radius: 50%;
            border: 1px solid var(--text-color);
            display: none;
        }

        .dock-app-item.open::after,
        .dock-app-item.minimized::after {
            display: block;
        }

        /* Updated: Styling for the dock separator */
        .dock-separator {
            width: 1px;
            background-color: var(--dock-border);
            height: 20px;
            /* Adjust height for desired gap */
            margin: auto 0;
            /* Center vertically with auto margins */
            flex-shrink: 0;
            /* Prevent separator from shrinking */
        }


        #context-menu {
            position: fixed;
            z-index: 10000;
            width: 200px;
            background-color: var(--dropdown-bg);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            padding: 4px;
        }

        #notification-toast {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            transition: bottom 0.5s ease-in-out;
            z-index: 200;
        }

        #notification-toast.show {
            bottom: 20px;
        }
    </style>
</head>

<body>
    <script>
        (function () {
            const savedDesign = localStorage.getItem('navigationDesign');
            if (savedDesign === 'sidebar') {
                window.location.replace('index.html');
            }
        })();
    </script>

    <canvas id="starfield-canvas"></canvas>

    <div id="mobile-redirect-overlay"
        class="fixed inset-0 bg-black bg-opacity-80 z-[20000] flex-col items-center justify-center text-white text-center p-8 hidden">
        <h2 class="text-2xl font-bold mb-4">Desktop-Ansicht nicht verfügbar</h2>
        <p>Diese Ansicht ist nur für größere Bildschirme optimiert. Sie werden zur mobilen Ansicht weitergeleitet.</p>
    </div>

    <header id="top-bar" class="fixed top-0 left-0 right-0 z-50 flex items-center justify-between p-2 px-4 h-8 text-sm">
        <div class="font-bold">dev0gig</div>
        <div id="clock" class="font-semibold"></div>
        <div class="flex items-center gap-2">
            <div class="top-bar-menu">
                <button id="theme-menu-btn" class="p-1 rounded-full hover:bg-gray-500/20">
                    <i data-lucide="sun"></i>
                </button>
                <div id="theme-dropdown" class="dropdown-menu hidden">
                    <div class="dropdown-item" data-theme-value="light">
                        <i data-lucide="sun"></i>
                        <span>Light</span>
                    </div>
                    <div class="dropdown-item" data-theme-value="dark">
                        <i data-lucide="moon"></i>
                        <span>Dark</span>
                    </div>
                    <div class="dropdown-item" data-theme-value="system">
                        <i data-lucide="monitor"></i>
                        <span>System</span>
                    </div>
                </div>
            </div>
            <div class="top-bar-menu">
                <button id="design-menu-btn" class="p-1 rounded-full hover:bg-gray-500/20">
                    <i data-lucide="panel-left"></i>
                </button>
                <div id="design-dropdown" class="dropdown-menu hidden">
                    <div class="dropdown-item active" data-design-value="desktop">
                        <i data-lucide="grid"></i>
                        <span>Desktop</span>
                    </div>
                    <div class="dropdown-item" data-design-value="sidebar">
                        <i data-lucide="panel-left"></i>
                        <span>Seitenleiste</span>
                    </div>
                </div>
            </div>
            <div class="top-bar-menu">
                <button id="data-menu-btn" class="p-1 rounded-full hover:bg-gray-500/20">
                    <i data-lucide="database"></i>
                </button>
                <div id="data-dropdown" class="dropdown-menu hidden">
                    <div id="backup-btn" class="dropdown-item">
                        <i data-lucide="download"></i>
                        <span>Backup All</span>
                    </div>
                    <label for="restore-input" id="restore-btn" class="dropdown-item">
                        <i data-lucide="upload"></i>
                        <span>Restore All</span>
                    </label>
                    <input type="file" id="restore-input" class="hidden" accept=".zip">
                    <div class="dropdown-separator"></div>
                    <div id="delete-btn" class="dropdown-item text-red-500 hover:!bg-red-500 hover:!text-white">
                        <i data-lucide="trash-2"></i>
                        <span>Delete All</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main id="desktop">
        <!-- Desktop icons will be generated here -->
    </main>

    <div id="app-dock">
        <!-- Favorite and open apps will be generated here -->
    </div>

    <div id="modal-overlay" class="hidden fixed inset-0 bg-black bg-opacity-70 z-[10001]"></div>
    <div id="confirm-modal"
        class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-md rounded-lg shadow-2xl p-6 z-[10002]">
        <div class="flex items-center justify-between mb-4">
            <h3 id="confirm-modal-title" class="text-xl font-bold" style="color: var(--text-color);"></h3>
            <button id="close-confirm-modal-btn" class="hover:text-white text-2xl"
                style="color: var(--text-color-light);">&times;</button>
        </div>
        <p id="confirm-modal-text" class="mb-6" style="color: var(--text-color-light);"></p>
        <div class="flex justify-end gap-4">
            <button id="confirm-modal-cancel-btn" class="font-bold py-2 px-4 rounded-lg transition"
                style="background-color: var(--dock-border); color: var(--text-color);">Abbrechen</button>
            <button id="confirm-modal-confirm-btn"
                class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition">Bestätigen</button>
        </div>
    </div>

    <div id="notification-toast"></div>

    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            // Redirect to mobile view if screen width is too small
            if (window.innerWidth < 1024) {
                const overlay = document.getElementById('mobile-redirect-overlay');
                if (overlay) overlay.style.display = 'flex';
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 3000);
                return;
            }

            const desktop = document.getElementById('desktop');
            const appDock = document.getElementById('app-dock');
            const clockElement = document.getElementById('clock');
            const notificationToast = document.getElementById('notification-toast');
            const modalOverlay = document.getElementById('modal-overlay');

            lucide.createIcons();

            // Define the applications available on the desktop
            const apps = [
                { id: 'appdrawer', name: 'Appdrawer', icon: 'assets/icons/appdrawer.svg', src: 'tabs/appdrawer.html' },
                { id: 'widgets', name: 'Widgets', icon: 'assets/icons/widgets.svg', src: 'tabs/widgets-iframe.html' },
                { id: 'readlater', name: 'ReadlateR', icon: 'assets/icons/readlater.svg', src: 'tabs/readlater.html' },
                { id: 'rss', name: 'RSS Reader', icon: 'assets/icons/rss.svg', src: 'tabs/rss-reader.html' },
                { id: 'aurimea', name: 'AuriMea', icon: 'assets/icons/aurimea.svg', src: 'tabs/aurimea.html' },
                { id: 'memomea', name: 'MemoMea', icon: 'assets/icons/memomea.svg', src: 'tabs/memomea.html' },
            ];

            let highestZIndex = 100; // Z-index for managing window stacking
            let iconPositions = JSON.parse(localStorage.getItem('desktopIconPositions')) || {}; // Saved desktop icon positions

            let openWindows = new Set(); // Set of currently open window IDs
            let minimizedWindows = new Set(); // Set of currently minimized window IDs

            /**
             * Saves the current state of open and minimized windows to localStorage.
             */
            function saveWindowState() {
                const state = {
                    open: [...openWindows],
                    minimized: [...minimizedWindows],
                };
                localStorage.setItem('desktopWindowState', JSON.stringify(state));
            }

            /**
             * Displays a toast notification.
             * @param {string} message - The message to display.
             * @param {'success'|'error'|'info'} type - The type of notification (determines color).
             * @param {number} duration - How long the toast should be visible in milliseconds (0 for indefinite).
             */
            const showToast = (message, type = 'success', duration = 3000) => {
                notificationToast.textContent = message;
                notificationToast.className = 'show'; // Show the toast
                if (type === 'success') notificationToast.style.backgroundColor = '#22c55e';
                else if (type === 'error') notificationToast.style.backgroundColor = '#ef4444';
                else notificationToast.style.backgroundColor = '#525252';

                if (duration > 0) {
                    setTimeout(() => { notificationToast.className = ''; }, duration); // Hide after duration
                }
            };

            /**
             * Opens a confirmation modal.
             * @param {string} title - The title of the confirmation modal.
             * @param {string} text - The main text message of the confirmation.
             * @param {function} onConfirm - Callback function to execute if the user confirms.
             */
            const openConfirmModal = (title, text, onConfirm) => {
                const confirmModal = document.getElementById('confirm-modal');
                document.getElementById('confirm-modal-title').textContent = title;
                document.getElementById('confirm-modal-text').textContent = text;

                // Clone and replace the confirm button to remove old event listeners
                const confirmBtn = document.getElementById('confirm-modal-confirm-btn');
                const newConfirmBtn = confirmBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

                newConfirmBtn.addEventListener('click', () => {
                    if (typeof onConfirm === 'function') {
                        onConfirm();
                    }
                    closeConfirmModal();
                });
                confirmModal.classList.remove('hidden');
                modalOverlay.classList.remove('hidden'); // Show overlay when modal is open
            };

            /**
             * Closes the confirmation modal.
             */
            const closeConfirmModal = () => {
                document.getElementById('confirm-modal').classList.add('hidden');
                modalOverlay.classList.add('hidden'); // Hide overlay when modal is closed
            };
            document.getElementById('confirm-modal-cancel-btn').addEventListener('click', closeConfirmModal);
            document.getElementById('close-confirm-modal-btn').addEventListener('click', closeConfirmModal);


            /**
             * Updates the clock display in the top bar.
             */
            function updateClock() {
                const now = new Date();
                const dateOptions = { weekday: 'long', month: 'long', day: 'numeric' };
                const timeOptions = { hour: '2-digit', minute: '2-digit' };
                const dateString = now.toLocaleDateString('de-DE', dateOptions);
                const timeString = now.toLocaleTimeString('de-DE', timeOptions);
                clockElement.textContent = `${dateString} | ${timeString}`;
            }
            setInterval(updateClock, 1000); // Update clock every second
            updateClock(); // Initial call to display clock immediately

            /**
             * Creates and displays an application window.
             * @param {object} app - The application object containing id, name, and src.
             */
            function createWindow(app) {
                const existingWindow = document.getElementById(`window-${app.id}`);
                if (existingWindow) {
                    if (minimizedWindows.has(app.id)) {
                        restoreWindow(app.id); // Restore if minimized
                    }
                    bringToFront(existingWindow); // Bring to front if already open
                    return;
                }

                openWindows.add(app.id); // Add to open windows set
                renderAppDock(); // Update the dock
                saveWindowState(); // Save state after opening

                const appWindow = document.createElement('div');
                appWindow.id = `window-${app.id}`;
                appWindow.className = 'app-window';

                const header = document.createElement('div');
                header.className = 'app-window-header';

                const title = document.createElement('h3');
                title.textContent = app.name;

                const controls = document.createElement('div');
                controls.className = 'window-controls';

                // Minimize button
                const minimizeBtn = document.createElement('button');
                minimizeBtn.className = 'window-control-btn minimize';
                minimizeBtn.innerHTML = `<i data-lucide="minus"></i>`;
                minimizeBtn.title = 'Minimieren';
                minimizeBtn.onclick = () => minimizeWindow(app.id);
                controls.appendChild(minimizeBtn);

                // Arrange/Snap button
                const arrangeBtn = document.createElement('button');
                arrangeBtn.className = 'window-control-btn arrange';
                arrangeBtn.innerHTML = `<i data-lucide="maximize"></i>`;
                controls.appendChild(arrangeBtn);

                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.className = 'window-control-btn close';
                closeBtn.innerHTML = `<i data-lucide="x"></i>`;
                closeBtn.onclick = () => {
                    appWindow.remove(); // Remove window from DOM
                    openWindows.delete(app.id); // Remove from open set
                    minimizedWindows.delete(app.id); // Ensure it's not in minimized set
                    renderAppDock(); // Update dock
                    saveWindowState(); // Save state after closing
                };

                controls.appendChild(closeBtn);
                header.appendChild(title);
                header.appendChild(controls);

                const content = document.createElement('div');
                content.className = 'app-window-content';

                // Loader for iframe content
                const loader = document.createElement('div');
                loader.className = 'window-loader';
                const loaderImg = document.createElement('img');
                loaderImg.src = 'assets/loading/zzz-loading.gif';
                loaderImg.alt = 'Ladeanimation';
                loaderImg.className = 'w-20';
                loader.appendChild(loaderImg);
                content.appendChild(loader);

                const iframe = document.createElement('iframe');
                iframe.src = app.src;
                iframe.dataset.key = app.id; // Store app ID for messaging
                iframe.onload = () => {
                    setTimeout(() => { loader.remove(); }, 200); // Remove loader after content loads
                    const savedTheme = localStorage.getItem('theme') || 'system';
                    let effectiveTheme = savedTheme === 'system' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : savedTheme;
                    applyThemeToFrame(iframe, effectiveTheme); // Apply theme to iframe content
                    if (app.id === 'appdrawer') {
                        iframe.contentWindow.postMessage('getFavorites', '*'); // Request favorites from appdrawer
                    }
                };
                content.appendChild(iframe);

                appWindow.appendChild(header);
                appWindow.appendChild(content);

                desktop.appendChild(appWindow);
                snapWindow(appWindow, 'fullscreen'); // Default to fullscreen
                bringToFront(appWindow); // Bring new window to front

                appWindow.addEventListener('mousedown', () => bringToFront(appWindow), true); // Bring to front on click

                // Arrange/Snap menu for window positioning
                const arrangeMenu = document.createElement('div');
                arrangeMenu.className = 'dropdown-menu hidden';
                arrangeMenu.style.width = 'auto';
                arrangeMenu.style.right = '4px';
                arrangeMenu.style.zIndex = '10002';
                arrangeMenu.innerHTML = `
                    <div class="dropdown-item" data-snap="left"><i data-lucide="align-left"></i><span>Snap Left</span></div>
                    <div class="dropdown-item" data-snap="right"><i data-lucide="align-right"></i><span>Snap Right</span></div>
                    <div class="dropdown-item" data-snap="fullscreen"><i data-lucide="maximize"></i><span>Fullscreen</span></div>
                `;
                arrangeBtn.parentElement.appendChild(arrangeMenu);

                arrangeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent document click from closing immediately
                    document.querySelectorAll('.dropdown-menu').forEach(m => {
                        if (m !== arrangeMenu) m.classList.add('hidden'); // Hide other dropdowns
                    });
                    arrangeMenu.classList.toggle('hidden'); // Toggle visibility of this menu
                    lucide.createIcons(); // Re-render icons for the menu
                });

                arrangeMenu.addEventListener('click', (e) => {
                    const snapTarget = e.target.closest('.dropdown-item');
                    if (snapTarget) {
                        snapWindow(appWindow, snapTarget.dataset.snap); // Snap window based on selection
                        arrangeMenu.classList.add('hidden'); // Hide menu after selection
                    }
                });
                lucide.createIcons();
            }

            /**
             * Minimizes an application window.
             * @param {string} appId - The ID of the application to minimize.
             */
            function minimizeWindow(appId) {
                const appWindow = document.getElementById(`window-${appId}`);
                if (appWindow) {
                    appWindow.style.display = 'none'; // Hide the window
                    minimizedWindows.add(appId); // Add to minimized set
                    openWindows.delete(appId); // Remove from open set
                    renderAppDock(); // Update dock
                    saveWindowState(); // Save state after minimizing
                }
            }

            /**
             * Restores a minimized application window.
             * @param {string} appId - The ID of the application to restore.
             */
            function restoreWindow(appId) {
                const appWindow = document.getElementById(`window-${appId}`);
                if (appWindow) {
                    appWindow.style.display = 'flex'; // Show the window
                    bringToFront(appWindow); // Bring to front
                    minimizedWindows.delete(appId); // Remove from minimized set
                    openWindows.add(appId); // Add to open set
                    renderAppDock(); // Update dock
                    saveWindowState(); // Save state after restoring
                }
            }

            /**
             * Brings a given element (window) to the front by updating its z-index.
             * @param {HTMLElement} el - The element to bring to front.
             */
            function bringToFront(el) {
                highestZIndex++;
                el.style.zIndex = highestZIndex;
            }

            /**
             * Snaps a window to a specific position (left, right, fullscreen).
             * @param {HTMLElement} element - The window element to snap.
             * @param {'left'|'right'|'fullscreen'} direction - The direction to snap the window.
             */
            function snapWindow(element, direction) {
                const topBarHeight = 32; // Height of the top bar
                // Ensure dock is visible to get correct height, otherwise default to 0
                const appDockHeight = appDock.offsetHeight || 0;

                // Store the snap state on the element for resize handling
                element.dataset.snapState = direction;

                if (direction === 'left') {
                    element.style.left = '0px';
                    element.style.top = `${topBarHeight}px`;
                    element.style.width = '50vw';
                    element.style.height = `calc(100vh - ${topBarHeight}px - ${appDockHeight}px - 8px)`;
                } else if (direction === 'right') {
                    element.style.left = '50vw';
                    element.style.top = `${topBarHeight}px`;
                    element.style.width = '50vw';
                    element.style.height = `calc(100vh - ${topBarHeight}px - ${appDockHeight}px - 8px)`;
                } else if (direction === 'fullscreen') {
                    element.style.top = `${topBarHeight}px`;
                    element.style.left = '0px';
                    element.style.width = '100vw';
                    element.style.height = `calc(100vh - ${topBarHeight}px - ${appDockHeight}px - 8px)`;
                }
            }

            /**
             * Makes a desktop icon draggable and handles opening the app on click.
             * @param {HTMLElement} icon - The icon element.
             * @param {object} app - The application object associated with the icon.
             */
            function makeIconDraggable(icon, app) {
                let hasMoved = false;
                let startX, startY;
                const DRAG_THRESHOLD = 5; // Minimum distance to consider it a drag

                icon.onmousedown = (e) => {
                    if (e.button !== 0) return; // Only left-click
                    e.preventDefault();
                    hasMoved = false;
                    startX = e.clientX;
                    startY = e.clientY;

                    document.addEventListener('mousemove', elementDrag);
                    document.addEventListener('mouseup', closeDragElement);
                };

                function elementDrag(moveEvent) {
                    moveEvent.preventDefault();
                    const dx = moveEvent.clientX - startX;
                    const dy = moveEvent.clientY - startY;

                    if (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD) {
                        hasMoved = true;
                    }

                    if (hasMoved) {
                        icon.style.left = `${icon.offsetLeft + dx}px`;
                        icon.style.top = `${icon.offsetTop + dy}px`;
                        startX = moveEvent.clientX;
                        startY = moveEvent.clientY;
                    }
                }

                function closeDragElement() {
                    document.removeEventListener('mousemove', elementDrag);
                    document.removeEventListener('mouseup', closeDragElement);

                    if (hasMoved) {
                        // Save new position if dragged
                        iconPositions[icon.id] = { top: icon.style.top, left: icon.style.left };
                        localStorage.setItem('desktopIconPositions', JSON.stringify(iconPositions));
                    } else {
                        // Open window if not dragged (i.e., a click)
                        createWindow(app);
                    }
                }
            }

            /**
             * Creates and positions desktop icons.
             */
            function createDesktopIcons() {
                apps.forEach((app, index) => {
                    const icon = document.createElement('div');
                    icon.id = `icon-${app.id}`;
                    icon.className = 'desktop-icon';

                    const img = document.createElement('img');
                    img.src = app.icon;
                    img.alt = app.name;

                    const span = document.createElement('span');
                    span.textContent = app.name;

                    icon.appendChild(img);
                    icon.appendChild(span);

                    // Apply saved position or default position
                    if (iconPositions[icon.id]) {
                        icon.style.top = iconPositions[icon.id].top;
                        icon.style.left = iconPositions[icon.id].left;
                    } else {
                        icon.style.top = `${50 + (index % 8) * 100}px`;
                        icon.style.left = `${50 + Math.floor(index / 8) * 100}px`;
                    }

                    desktop.appendChild(icon);
                    makeIconDraggable(icon, app);
                });
            }

            /**
             * Applies the selected theme to an iframe's content.
             * @param {HTMLIFrameElement} frame - The iframe element.
             * @param {string} theme - The theme to apply ('light', 'dark', or 'system').
             */
            function applyThemeToFrame(frame, theme) {
                if (frame && frame.contentWindow) {
                    frame.contentWindow.postMessage(`set-theme-${theme}`, '*');
                }
            }

            /**
             * Applies the selected theme to the entire document and all open iframes.
             * @param {string} theme - The theme to apply ('light', 'dark', or 'system').
             */
            function applyTheme(theme) {
                // Determine effective theme for 'system' setting
                let effectiveTheme = theme === 'system' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme;
                document.documentElement.setAttribute('data-theme', effectiveTheme);

                // Highlight active theme in dropdown
                document.querySelectorAll('#theme-dropdown .dropdown-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.themeValue === theme) {
                        item.classList.add('active');
                    }
                });

                // Apply dynamic or static background based on theme
                if (effectiveTheme === 'light') {
                    document.body.classList.remove('dynamic-background');
                    document.body.classList.add('static-background');
                } else {
                    document.body.classList.add('dynamic-background');
                    document.body.classList.remove('static-background');
                }

                // Update theme icon in top bar
                const themeIcon = document.querySelector('#theme-menu-btn .lucide');
                if (effectiveTheme === 'light') themeIcon.setAttribute('data-lucide', 'sun');
                else themeIcon.setAttribute('data-lucide', 'moon');
                lucide.createIcons(); // Re-render Lucide icons

                // Apply theme to desktop icons and dock icons
                document.querySelectorAll('.desktop-icon img').forEach(img => {
                    if (effectiveTheme === 'dark') {
                        img.style.filter = 'invert(1)';
                    } else {
                        img.style.filter = 'none';
                    }
                });

                document.querySelectorAll('.dock-desktop-icon').forEach(img => {
                    if (effectiveTheme === 'dark') {
                        img.style.filter = 'invert(1)';
                    } else {
                        img.style.filter = 'none';
                    }
                });

                // Apply theme to all open iframes
                document.querySelectorAll('.app-window iframe').forEach(frame => {
                    applyThemeToFrame(frame, effectiveTheme);
                });
            }

            /**
             * Sets up dropdown menus in the top bar.
             */
            function setupDropdowns() {
                const menus = [
                    { btn: 'theme-menu-btn', dropdown: 'theme-dropdown' },
                    { btn: 'design-menu-btn', dropdown: 'design-dropdown' },
                    { btn: 'data-menu-btn', dropdown: 'data-dropdown' },
                ];

                menus.forEach(menu => {
                    const btn = document.getElementById(menu.btn);
                    const dropdown = document.getElementById(menu.dropdown);
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent click from bubbling to window and closing dropdown
                        menus.forEach(otherMenu => {
                            if (otherMenu.dropdown !== menu.dropdown) {
                                document.getElementById(otherMenu.dropdown).classList.add('hidden'); // Hide other dropdowns
                            }
                        });
                        dropdown.classList.toggle('hidden'); // Toggle visibility of current dropdown
                        lucide.createIcons(); // Re-render icons
                    });
                });

                // Close all dropdowns when clicking anywhere else on the window
                window.addEventListener('click', () => {
                    menus.forEach(menu => document.getElementById(menu.dropdown).classList.add('hidden'));
                });
            }

            // Event listeners for theme selection in dropdown
            document.querySelectorAll('#theme-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', () => {
                    const theme = item.dataset.themeValue;
                    localStorage.setItem('theme', theme); // Save selected theme
                    applyTheme(theme); // Apply selected theme
                });
            });

            // Event listeners for design selection in dropdown
            document.querySelectorAll('#design-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', () => {
                    const designValue = item.dataset.designValue;
                    localStorage.setItem('navigationDesign', designValue); // Save selected design
                    if (designValue === 'sidebar') {
                        window.location.href = 'index.html'; // Redirect to sidebar view
                    }
                });
            });

            // --- DATA MANAGEMENT FUNCTIONS ---

            /**
             * Creates a ZIP file containing backup data and triggers its download.
             * @param {object} backupData - The data object to be backed up.
             */
            const createAndDownloadZip = (backupData) => {
                const zip = new JSZip();
                let filesAdded = 0;
                for (const key in backupData) {
                    if (backupData[key] !== null && backupData[key] !== undefined) {
                        zip.file(`${key}.json`, JSON.stringify(backupData[key], null, 2));
                        filesAdded++;
                    }
                }
                if (filesAdded === 0) {
                    showToast('Keine Daten zum Sichern gefunden.', 'info');
                    return;
                }
                zip.generateAsync({ type: "blob" })
                    .then(content => {
                        const link = document.createElement('a');
                        const date = new Date().toISOString().slice(0, 10); // Format date as YYYY-MM-DD
                        link.href = URL.createObjectURL(content);
                        link.download = `dashboard-backup-${date}.zip`; // Filename for download
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        showToast('Backup erfolgreich heruntergeladen!', 'success');
                    })
                    .catch(err => {
                        console.error('Zip generation failed:', err);
                        showToast('Backup-Erstellung fehlgeschlagen.', 'error');
                    });
            };

            // Event listener for the "Backup All" button
            document.getElementById('backup-btn').addEventListener('click', () => {
                let backupData = {};
                const contentFrames = document.querySelectorAll('.app-window iframe');
                // Filter for iframes that have a data-key and a src (i.e., loaded apps)
                const backupFrames = Array.from(contentFrames).filter(f => f.dataset.key && f.src);
                let expectedResponses = backupFrames.length;
                let receivedResponses = 0;

                // Include shell settings and appdrawer data directly
                backupData['shell_settings'] = {
                    theme: localStorage.getItem('theme') || 'system',
                    desktopIconPositions: JSON.parse(localStorage.getItem('desktopIconPositions') || '{}')
                };
                // Get appdrawer data from localStorage directly, as it's not in an iframe
                backupData['appdrawer'] = {
                    apps: JSON.parse(localStorage.getItem('userApps') || '[]'),
                    favorites: JSON.parse(localStorage.getItem('favoriteApps') || '[]')
                };

                // If no iframes to backup (only shell/appdrawer data), proceed directly
                if (expectedResponses === 0) {
                    showToast('Keine geladenen Apps zum Sichern gefunden. Nur Systemdaten werden gesichert.', 'info');
                    createAndDownloadZip(backupData);
                    return;
                }

                showToast('Backup wird gestartet...', 'info', 0); // Indefinite toast

                // Timeout for unresponsive iframes
                const backupTimeoutId = setTimeout(() => {
                    const respondedKeys = Object.keys(backupData);
                    const allKeys = backupFrames.map(f => f.dataset.key);
                    const missingKeys = allKeys.filter(k => !respondedKeys.includes(k));
                    if (missingKeys.length > 0) {
                        showToast('Backup-Timeout. Folgende Apps haben nicht geantwortet: ' + missingKeys.join(', '), 'error', 8000);
                    }
                    // Even if timeout, generate zip with what's available
                    createAndDownloadZip(backupData);
                }, 10000); // 10 seconds timeout

                // Message listener for backup data responses from iframes
                const messageListener = (event) => {
                    const { type, key, data } = event.data;
                    if (type === 'backupDataResponse') {
                        if (key) { backupData[key] = data; } // Store data by app key
                        receivedResponses++;
                        // If all expected responses received, clear timeout and create zip
                        if (receivedResponses === expectedResponses) {
                            clearTimeout(backupTimeoutId);
                            window.removeEventListener('message', messageListener); // Remove listener
                            createAndDownloadZip(backupData);
                        }
                    }
                };
                window.addEventListener('message', messageListener);

                // Request backup data from each iframe
                backupFrames.forEach(frame => {
                    frame.contentWindow.postMessage({ type: 'getBackupData' }, '*');
                });
            });

            // Event listener for the "Restore All" input (file selection)
            document.getElementById('restore-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                openConfirmModal('Daten wiederherstellen?', 'Dies wird alle aktuellen Einstellungen und Anwendungsdaten überschreiben und die Seite neu laden. Fortfahren?', async () => {
                    showToast('Wiederherstellung wird gestartet...', 'info', 0); // Indefinite toast
                    try {
                        const zip = await JSZip.loadAsync(file);
                        let restoredCount = 0;
                        const zipFiles = Object.keys(zip.files);

                        // Process shell settings first
                        const shellFile = zip.file('shell_settings.json');
                        if (shellFile) {
                            const content = await shellFile.async('string');
                            const settings = JSON.parse(content);
                            for (const key in settings) {
                                const value = settings[key];
                                // Handle desktopIconPositions which is an object
                                localStorage.setItem(key, typeof value === 'object' ? JSON.stringify(value) : value);
                            }
                        }

                        // Process appdrawer data (userApps and favoriteApps)
                        const appDrawerFile = zip.file('appdrawer.json');
                        if (appDrawerFile) {
                            const content = await appDrawerFile.async('string');
                            const appDrawerData = JSON.parse(content);
                            if (appDrawerData.apps) {
                                localStorage.setItem('userApps', JSON.stringify(appDrawerData.apps));
                            }
                            if (appDrawerData.favorites) {
                                localStorage.setItem('favoriteApps', JSON.stringify(appDrawerData.favorites));
                            }
                        }

                        // Create a temporary container for iframes used during restore
                        const tempContainer = document.createElement('div');
                        tempContainer.style.display = 'none';
                        document.body.appendChild(tempContainer);

                        const restorePromises = []; // To track all iframe restore operations

                        for (const filename of zipFiles) {
                            // Only process JSON files that are not shell_settings or appdrawer
                            if (filename.endsWith('.json') && filename !== 'shell_settings.json' && filename !== 'appdrawer.json') {
                                const key = filename.replace('.json', '');
                                const appToRestore = apps.find(app => app.id === key); // Find the corresponding app definition

                                if (appToRestore) {
                                    const content = await zip.file(filename).async('string');
                                    const dataToRestore = JSON.parse(content);

                                    // Create a promise for each iframe restore operation
                                    const promise = new Promise((resolve, reject) => {
                                        const iframe = document.createElement('iframe');
                                        iframe.dataset.key = key; // Set data-key for identification
                                        iframe.src = appToRestore.src; // Load the app into the iframe

                                        iframe.onload = () => {
                                            // Once iframe is loaded, send the restore data
                                            iframe.contentWindow.postMessage({ type: 'restoreBackupData', data: dataToRestore }, '*');
                                            restoredCount++;
                                            resolve(); // Resolve the promise
                                        };
                                        iframe.onerror = reject; // Reject on error
                                        tempContainer.appendChild(iframe); // Add iframe to temporary container
                                    });
                                    restorePromises.push(promise);
                                }
                            }
                        }

                        await Promise.all(restorePromises); // Wait for all iframe restores to complete

                        // Clean up temporary container
                        if (document.body.contains(tempContainer)) document.body.removeChild(tempContainer);
                        showToast(`${restoredCount} App(s) erfolgreich wiederhergestellt. Die Seite wird neu geladen.`, 'success');
                        setTimeout(() => window.location.reload(), 2000); // Reload after successful restore

                    } catch (err) {
                        console.error('Restore failed:', err);
                        showToast('Wiederherstellung fehlgeschlagen. Ist es eine gültige Backup-Datei?', 'error');
                    } finally {
                        event.target.value = ''; // Clear the file input
                    }
                });
            });


            // Event listener for the "Delete All" button
            document.getElementById('delete-btn').addEventListener('click', () => {
                openConfirmModal(
                    'Alle Daten löschen?',
                    'Möchten Sie wirklich ALLE Anwendungsdaten und Einstellungen aus Ihrem Browser löschen? Diese Aktion kann nicht rückgängig gemacht werden!',
                    () => {
                        localStorage.clear(); // Clear all localStorage data
                        showToast('Alle Daten wurden gelöscht. Die Seite wird neu geladen.', 'success');
                        setTimeout(() => window.location.reload(), 1500); // Reload after deletion
                    }
                );
            });

            /**
             * Renders or updates the application dock.
             */
            function renderAppDock() {
                const userApps = JSON.parse(localStorage.getItem('userApps') || '[]');
                const favoriteIds = new Set(JSON.parse(localStorage.getItem('favoriteApps') || '[]'));
                // Combine desktop apps and user-added apps to get all available apps
                const allAvailableApps = [...apps, ...userApps];

                appDock.innerHTML = ''; // Clear current dock content

                // Filter for favorite apps
                const favoriteApps = [...favoriteIds].map(id => allAvailableApps.find(app => app.id === id)).filter(Boolean);
                // Filter for open/minimized non-favorite apps
                const openNonFavoriteApps = [...openWindows, ...minimizedWindows]
                    .filter(id => !favoriteIds.has(id))
                    .map(id => allAvailableApps.find(app => app.id === id))
                    .filter(Boolean);

                appDock.style.display = 'flex'; // Ensure dock is visible

                /**
                 * Creates a single dock item element.
                 * @param {object} app - The application object.
                 * @returns {HTMLElement} The created dock item element.
                 */
                const createDockItem = (app) => {
                    const item = document.createElement('div');
                    item.className = 'dock-app-item';
                    item.title = app.name;
                    item.dataset.appId = app.id;

                    const icon = document.createElement('img');
                    icon.src = app.icon || app.iconUrl; // Use app.icon for desktop apps, app.iconUrl for user apps
                    const isDesktopApp = apps.some(desktopApp => desktopApp.id === app.id);
                    icon.className = isDesktopApp ? 'w-12 h-12 pointer-events-none dock-desktop-icon' : 'w-12 h-12 rounded-full shadow-lg pointer-events-none';
                    icon.onerror = function () { this.src = `https://placehold.co/64x64/e0e0e0/ffffff?text=${(app.name || 'A').charAt(0)}`; };
                    item.appendChild(icon);

                    // Add 'open' or 'minimized' class if applicable
                    if (openWindows.has(app.id)) item.classList.add('open');
                    if (minimizedWindows.has(app.id)) item.classList.add('minimized');

                    // Click handler for dock items
                    item.addEventListener('click', () => {
                        const appDefinition = allAvailableApps.find(a => a.id === app.id);
                        if (!appDefinition) return;

                        if (minimizedWindows.has(app.id)) {
                            restoreWindow(app.id); // Restore if minimized
                        } else if (openWindows.has(app.id)) {
                            const windowEl = document.getElementById(`window-${app.id}`);
                            if (windowEl) bringToFront(windowEl); // Bring to front if already open
                        } else {
                            if (appDefinition.src) { // Internal app (opens in a window)
                                createWindow(appDefinition);
                            } else if (appDefinition.url) { // External app (opens in new tab)
                                window.open(appDefinition.url, '_blank');
                            }
                        }
                    });

                    // Context menu handler for dock items
                    item.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, app.id);
                    });

                    return item;
                };

                // Add favorite apps to the dock
                favoriteApps.forEach(app => appDock.appendChild(createDockItem(app)));

                // Add a separator if both favorite and non-favorite open apps exist
                if (favoriteApps.length > 0 && openNonFavoriteApps.length > 0) {
                    const separator = document.createElement('div');
                    separator.className = 'dock-separator';
                    appDock.appendChild(separator);
                }

                // Add open/minimized non-favorite apps to the dock
                openNonFavoriteApps.forEach(app => appDock.appendChild(createDockItem(app)));

                // Apply current theme to dock icons
                applyTheme(localStorage.getItem('theme') || 'system');
            }

            /**
             * Displays a context menu for dock items.
             * @param {number} x - X coordinate for menu position.
             * @param {number} y - Y coordinate for menu position.
             * @param {string} appId - The ID of the app for which the context menu is shown.
             */
            function showContextMenu(x, y, appId) {
                const existingMenu = document.getElementById('context-menu');
                if (existingMenu) existingMenu.remove(); // Remove any existing context menu

                const menu = document.createElement('div');
                menu.id = 'context-menu';
                menu.style.top = `${y}px`;
                menu.style.left = `${x}px`;

                let favorites = JSON.parse(localStorage.getItem('favoriteApps') || '[]');
                const isFavorited = favorites.includes(appId);

                // Create "Add/Remove Favorite" item
                const toggleFavoriteItem = document.createElement('div');
                toggleFavoriteItem.className = 'dropdown-item';

                if (isFavorited) {
                    toggleFavoriteItem.innerHTML = `<i data-lucide="star-off" class="text-red-500"></i><span class="text-red-500">Favorit entfernen</span>`;
                } else {
                    toggleFavoriteItem.innerHTML = `<i data-lucide="star" class="text-yellow-400"></i><span>Zu Favoriten hinzufügen</span>`;
                }

                toggleFavoriteItem.onclick = () => {
                    if (isFavorited) {
                        favorites = favorites.filter(id => id !== appId);
                    } else {
                        favorites.push(appId);
                    }
                    localStorage.setItem('favoriteApps', JSON.stringify(favorites)); // Update favorites in localStorage
                    renderAppDock(); // Re-render dock to reflect changes
                    menu.remove(); // Close context menu
                };

                menu.appendChild(toggleFavoriteItem);
                document.body.appendChild(menu); // Add menu to body

                // Close menu when clicking outside
                setTimeout(() => {
                    window.addEventListener('click', () => menu.remove(), { once: true });
                }, 0);
                lucide.createIcons(); // Re-render Lucide icons in the menu
            }

            // Listen for storage changes and messages for robust synchronization
            window.addEventListener('storage', (e) => {
                if (e.key === 'favoriteApps' || e.key === 'userApps') {
                    console.log('Desktop view detected storage change, re-rendering dock.');
                    renderAppDock(); // Re-render dock if favorite or user apps change
                }
            });

            window.addEventListener('message', (event) => {
                const { type, key, data } = event.data;
                if (type === 'favoritesUpdated') {
                    console.log('Desktop view received favoritesUpdated message, re-rendering dock.');
                    renderAppDock(); // Re-render dock if favorites are updated via message
                }
            });

            // Keyboard shortcuts for window management
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();

                // Alt + Q: Close, Alt + L: Snap Left, Alt + R: Snap Right, Alt + V: Fullscreen
                if (e.altKey && (key === 'q' || key === 'l' || key === 'r' || key === 'v')) {
                    e.preventDefault(); // Prevent default browser action

                    let activeWindow = null;
                    let maxZIndex = -1;

                    // Find the currently active (highest z-index) window
                    document.querySelectorAll('.app-window').forEach(windowEl => {
                        if (windowEl.style.display !== 'none') {
                            const currentZIndex = parseInt(windowEl.style.zIndex || 0, 10);
                            if (currentZIndex > maxZIndex) {
                                maxZIndex = currentZIndex;
                                activeWindow = windowEl;
                            }
                        }
                    });

                    if (activeWindow) {
                        const appId = activeWindow.id.replace('window-', '');
                        switch (key) {
                            case 'q':
                                activeWindow.remove();
                                openWindows.delete(appId);
                                minimizedWindows.delete(appId);
                                renderAppDock();
                                saveWindowState(); // Save state
                                break;
                            case 'l':
                                snapWindow(activeWindow, 'left');
                                break;
                            case 'r':
                                snapWindow(activeWindow, 'right');
                                break;
                            case 'v':
                                snapWindow(activeWindow, 'fullscreen');
                                break;
                        }
                    }
                }
            });

            // --- Starfield Background Logic ---
            const starfieldCanvas = document.getElementById('starfield-canvas');
            const ctx = starfieldCanvas.getContext('2d');
            let stars = [];

            /**
             * Sets up the starfield canvas and initializes stars.
             */
            function setupStarfield() {
                starfieldCanvas.width = window.innerWidth;
                starfieldCanvas.height = window.innerHeight;
                stars = [];
                const numStars = 150; // Number of stars
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * starfieldCanvas.width,
                        y: Math.random() * starfieldCanvas.height,
                        radius: Math.random() * 1.2 + 0.3, // Random size
                        alpha: Math.random() * 0.3 + 0.2, // Random transparency
                        vx: (Math.random() - 0.5) * 0.2, // Random horizontal velocity
                        vy: (Math.random() - 0.5) * 0.2 // Random vertical velocity
                    });
                }
            }

            /**
             * Animates the starfield, updating star positions and redrawing them.
             */
            function animateStarfield() {
                ctx.clearRect(0, 0, starfieldCanvas.width, starfieldCanvas.height); // Clear canvas
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Star color

                stars.forEach(star => {
                    star.x += star.vx;
                    star.y += star.vy;

                    // Wrap stars around the canvas edges
                    if (star.x < 0) star.x = starfieldCanvas.width;
                    if (star.x > starfieldCanvas.width) star.x = 0;
                    if (star.y < 0) star.y = starfieldCanvas.height;
                    if (star.y > starfieldCanvas.height) star.y = 0;

                    ctx.globalAlpha = star.alpha; // Apply star transparency
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1; // Reset global alpha

                requestAnimationFrame(animateStarfield); // Loop animation
            }

            /**
             * Loads and restores the previous window state (open and minimized windows).
             */
            function loadAndRestoreWindowState() {
                const savedState = JSON.parse(localStorage.getItem('desktopWindowState') || 'null');
                if (!savedState) return;

                // Create all previously open/minimized windows
                const allAppIds = [...new Set([...savedState.open, ...savedState.minimized])];
                allAppIds.forEach(appId => {
                    const app = apps.find(a => a.id === appId);
                    if (app) {
                        createWindow(app); // Create the window
                    }
                });

                // Minimize the ones that were minimized
                savedState.minimized.forEach(appId => {
                    const appWindow = document.getElementById(`window-${appId}`);
                    if (appWindow) {
                        minimizeWindow(appId); // Minimize the window
                    }
                });
            }

            // Add resize listener to adjust window snapping on screen resize
            window.addEventListener('resize', () => {
                document.querySelectorAll('.app-window').forEach(appWindow => {
                    // Re-snap only visible, snapped windows
                    if (appWindow.style.display !== 'none' && appWindow.dataset.snapState) {
                        snapWindow(appWindow, appWindow.dataset.snapState);
                    }
                });
                setupStarfield(); // Re-setup starfield on resize
            });


            // --- INITIALIZATION ---
            const savedTheme = localStorage.getItem('theme') || 'system';
            applyTheme(savedTheme); // Apply saved theme

            createDesktopIcons(); // Create desktop icons
            renderAppDock(); // Render the app dock
            setupDropdowns(); // Setup top bar dropdowns
            loadAndRestoreWindowState(); // Restore windows from previous session
            setupStarfield(); // Initialize starfield
            animateStarfield(); // Start starfield animation
        });
    </script>
</body>

</html>